\section{Choix argumentés}
TODO inclure UML ici

Le même objet est utilisé pour représenter le~plateau de tous les~jeux.
Ce~plateau n'est jamais manipulé directement par les~jeux :
les~objets représentant les~jeux génèrent des listes de coups possibles qui
seront ensuite utilisées par les~intelligences artificielles.
Pour savoir si un~mouvement est autorisé, il nous suffit de vérifier qu'il appartient à cette~liste. 

Du fait que les~jeux proposent tous une~liste de coups autorisés par les~règles,
les~intelligences artificielles sont indépendantes des jeux :
il suffit de modéliser les~différents types de mouvements et leurs~conséquences pour permettre à un~joueur humain ou au logiciel de jouer !

Le~jeu de \textit{tic tac toe} et \textit{puissance 4} ont une~caractéristique commune : 
les~conditions de victoire sont identiques, seul le~nombre de jetons diffère !
\textit{Puissance 4} ne fait qu'ajouter une~contrainte lorsqu'un~jeton est joué.

L'historique est géré sous la~forme d'une~pile : 
on ne peut défaire un~mouvement que lorsque c'est le~dernier effectué. 
Si on n'en tenait pas compte, on arriverait à des situations impossibles dans puissance~4 
(des jetons <<~voleraient~>>). Les~intelligences artificielles s'en servent abondamment pour explorer les différentes possibilités. 
Cela implique que l'affichage ainsi que les événements ne doivent pas toujours être mis à jour : lorsqu'une~IA <<~réfléchit~>>, les~mouvements effectués ne le sont pas réellement...

Les~succès et les~différents messages (sonores ou textuels) sont gérés à travers un~seul mécanisme : 
les~événements. Ces~derniers sont constitués de plusieurs compteurs nommés, mis à jour par le~jeu lui-même. 

L'utilisation du design patern observer pour eviter les incohérence entre l'interface graphique et l'état interne du programme.